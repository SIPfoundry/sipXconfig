#!/usr/bin/ruby

require 'optparse'
require 'fileutils'

# using only @VAR@ style vars in this section only helps make this maintainable when integrating
# patches.
$cfdatadir = "@SIPX_CFDATA@"
$logdir = "@SIPX_LOGDIR@"
$confdir = "@SIPX_CONFDIR@"
$bindir = "@SIPX_BINDIR@"
$user = "@SIPXPBXUSER@"
$group = "@SIPXPBXGROUP@"

$domain_dat = "#{$cfdatadir}/domain.cfdat"
$root_keydir = "/var/cfengine/ppkeys"
home_dir = `awk -F : '/#{$user}/ { print $6 }' /etc/passwd`.chomp
$user_keydir = "#{home_dir}/.cfagent/ppkeys"
$primary_dat = "#{$cfdatadir}/defaults/primary.cfdat"
$secondary_dat = "#{$cfdatadir}/defaults/secondary.cfdat"
$master_dat= "#{$cfdatadir}/defaults/setup"
$location_dat = "#{$cfdatadir}/defaults/location_id"
$log = "#{$logdir}/sipxecs-setup.log"
$verbose = false
$advanced = false
$exit_status = 0

def run_command(cmd)
  puts cmd if $verbose
  ok = system("#{cmd} >> #{$log} 2>&1")
  if (!ok) 
    puts
    puts  "Failure to run command #{cmd}. See #{$log} for details. After you"
    puts  "have addressed the issue, you may rerun this script."
    puts
    if $verbose
      system "cat #{$log}"
    end
    exit 1
  end
end

def set_root_keys
  #harmless if re-run  
  run_command "/usr/sbin/cf-key"
end

def set_nonroot_keys
  #harmless if re-run
  run_command "su - #{$user} sh -c '/usr/sbin/cf-key'"
end

def set_secondary
  return true if File.exists?($secondary_dat)
  puts "Configuring as an additional server..."

  master_address = prompt_required("Enter ip address or fully qualified host name of the primary server : ")

  location_id = prompt_required("Enter numeric id this additional server : ")
  File.open($location_dat,'w') {|f|
    f.puts location_id
  }
  location_dir = "#{$cfdatadir}/#{location_id}"
  Dir.mkdir(location_dir) unless File.directory?(location_dir)  
  
  master_cfdata = "#{$cfdatadir}"
  master_confdir = "#{$confdir}"
  if $advanced
    master_cfdata = prompt("Enter SIPX_CFDATA directory on master [ press enter for '#{master_cfdata}' ] : ", master_cfdata)
    master_confdir = prompt("Enter SIPX_CONFDIR directory on master [ press enter for '#{master_confdir}' ] : ", master_confdir)
  end
  File.open($master_dat,'w') {|f|
    f.puts "address=#{master_address}"
    f.puts "SIPX_CFDATA=#{master_cfdata}"
    f.puts "SIPX_CONFDIR=#{master_confdir}"
  }
  File.open($secondary_dat,'w') {|f|
    f.puts "+sipxsupervisor"
  }

  return true
end

def prompt_primary
  while true
    v = prompt_required("Is this the primary server or an additional server?  Enter 'p' for primary or 'a' for additional : ")
    return true if v == 'p'
    return false if v == 'a'
    puts "Invalid response."
  end
end

# Return true or false IF machine is primary, not is anything was done or not
def set_primary
  return false if File.exists?($secondary_dat)
  return true if File.exists?($primary_dat)
  return false unless prompt_primary
  puts "Configuring as the primary server..."
  File.open($location_dat, 'w') {|f|
    f.puts('1')
  }
  puts "Created #{$location_dat}" if $verbose
  File.open($primary_dat, 'w') {|f|
    f.puts <<EOF
+primary
+sipxsupervisor
+postgres
+mongod
EOF
  }
  puts "Created #{$primary_dat}" if $verbose
  return true
end

def prompt_confirm(msg)
  while (true)
    print msg
    value = readline.chomp.downcase
    return false if value == 'n'
    return true if value == 'y'
    puts "Invalid response. Please use 'y' or 'n'."
  end
end

def prompt_required(msg)
  print msg
  while (true)
    value = readline.chomp
    return value unless value.empty?
    puts "Invalid response, you must specify a value."
  end
  return value
end

def prompt(msg, default)
  print msg
  value = readline.chomp
  return value.empty? ? default : value
end

# PRIMARY ONLY
def set_domain
  return if File.exists?($domain_dat)
  current_host = `hostname -s`.chomp
  current_domain = `hostname -d`.chomp
  host = prompt("Enter system host name [ press enter for '#{current_host}' ] : ", current_host)
  domain = prompt("Enter domain name [ press enter for '#{current_domain}' ] : ", current_domain)
  fqdn = "#{host}.#{domain}"
  sip_domain = prompt("Enter SIP domain name [ press enter for '#{fqdn}' ] : ", fqdn)
  realm = prompt("Enter SIP realm [ press enter for '#{sip_domain}' ] : ", domain)
  # shared secret is not really used anymore, but some servers still read it
  shared_secret = `head -c 18 /dev/urandom | base64`.chomp
  File.open($domain_dat, 'w') { |f|
    f.puts <<EOF
=domain=#{sip_domain}
=realm=#{realm}
=secret=#{shared_secret}
=lang=en
=net_domain=#{domain}
EOF
  }
  puts "Created #{$domain_dat}" if $verbose
  FileUtils.chown($user, $group, $domain_dat)

  host_dat = "#{$cfdatadir}/1/host.cfdat"
  File.open(host_dat, 'w') { |f|
    f.puts <<EOF
=host=#{host}
EOF
  }  
  FileUtils.chown($user, $group, host_dat)
end

def rm_files(d)
  puts "clearing files in directory #{d}" if $verbose
  Dir.foreach(d) { |f|
    fname = "#{d}/#{f}"
    rm_file(fname) if File.file?(fname)
  }
end

def rm_file(f)
  puts "Checking if #{f} exists" if $verbose
  return unless File.exists?(f)
  puts "Removing #{f}" if $verbose
  File.unlink(f)
end

def reset
  rm_file($domain_dat)
  rm_file($primary_dat)
  rm_file($secondary_dat)
  rm_file($master_dat)
  rm_file($location_dat)
end

def reset_all
  reset
  rm_files($root_keydir)
  rm_files($user_keydir)
end

args = OptionParser.new { |opts|
  opts.banner = "Usage : sipxecs-setup [options]"

  opts.separator ""
  opts.separator "Options:"

  opts.on("--verbose", "Send extra details to console.") {
    $verbose = true
  }

  opts.on("--reset", "Force reset of normal settings.") {
    reset
  }

  opts.on("--reset-all", "Force reset of all possible settings including ssl keys.") {
    reset_all
  }

  opts.on("--advanced", "Ask advanced questions.") {
    $advanced = true
  }

  opts.on_tail("--help", "Print options") {
    puts opts
    exit
  }

}
args.parse!

raise 'Must run as root' unless Process.uid == 0
rm_file($log)
set_root_keys()
set_nonroot_keys()
if set_primary()
  set_domain()
else
  set_secondary
end

print "Configuring system, this may take a few minutes..."
run_command("#{$bindir}/sipxagent #{'-v' if $verbose}")
puts "done."
