#!/usr/bin/ruby

require 'optparse'

$domain_dat = "@SIPX_CFDATA@/domain.cfdat"
$root_keydir = "/var/cfengine/ppkeys"
home_dir = `awk -F : '/@SIPXPBXUSER@/ { print $6 }' /etc/passwd`.chomp
$user_keydir = "#{home_dir}/.cfagent/ppkeys"
$primary_dir = "@SIPX_CFDATA@/1"
$primary_dat = "#{$primary_dir}/primary.cfdat"
$location_dat = "@SIPX_CFDATA@/defaults/location_id"
$log = "@SIPX_LOGDIR@/sipxecs-setup.log"
$verbose = false
$cli_options = {}
$exit_status = 0

def run_command(cmd)
  puts cmd if $verbose
  ok = system("#{cmd} >> #{$log}")
  if (!ok) 
    puts  "Failure to run command #{cmd}. See #{$log} for details. After you"
    puts  "have addressed the issue, you may rerun this script."
    puts
    if $verbose
      system "cat #{$log}"
    end
    exit 1
  end
end

def set_root_keys
  #harmless if re-run  
  run_command "/usr/sbin/cf-key"
end

# PRIMARY ONLY
def set_nonroot_keys
  #harmless if re-run
  run_command "su - @SIPXPBXUSER@ sh -c '/usr/sbin/cf-key'"
end

# PRIMARY ONLY
def set_primary
  return if File.exists?($primary_dat)
  return if !prompt_confirm("Configure as primary machine? : [ enter y or n ] ")
  File.open($location_dat, 'w') {|f|
    f.puts('1')
  }
  puts "Created #{$location_dat}" if $verbose
  Dir.mkdir($primary_dir) unless File.directory?($primary_dir)
  File.open($primary_dat, 'w') {|f|
    f.puts <<EOF
+primary
+sipxsupervisor
+postgres
+mongod
EOF
  }
  puts "Created #{$primary_dat}" if $verbose
  `chown -R @SIPXPBXUSER@:@SIPXPBXGROUP@ #{$primary_dir}`
end

def prompt_confirm(msg)
  while (true)
    print msg
    value = readline.chomp.downcase
    return false if value == 'n'
    return true if value == 'y'
    puts "Invalid response. Please use 'y' or 'n'."
  end
end

def prompt(msg, default)
  print msg
  value = readline.chomp
  return value.empty? ? default : value
end

# PRIMARY ONLY
def set_domain
  return if File.exists?($domain_dat)
  current_fqdn = `hostname -f`.chomp
  fqdn = prompt("Enter fully qualified host name : [ press enter to use #{current_fqdn} ] ", current_fqdn)
  domain = prompt("Enter SIP domain name : [ press enter to use #{fqdn} ] ", fqdn)
  realm = prompt("Enter SIP realm : [ press enter to use #{domain} ] ", domain)
  new_secret = `head -c 18 /dev/urandom | base64`.chomp
  shared_secret = prompt("Enter shared secret : [ press enter to use random value ] ", new_secret) 
  File.open($domain_dat, 'w') { |f|
    f.puts <<EOF
=domain=#{domain}
=realm=#{realm}
=secret=#{shared_secret}
=lang=en
EOF
  }
  puts "Created #{$domain_dat}" if $verbose
  `chown @SIPXPBXUSER@:@SIPXPBXGROUP@ #{$domain_dat}`
end

def rm_files(d)
  puts "clearing files in directory #{d}" if $verbose
  Dir.foreach(d) { |f|
    fname = "#{d}/#{f}"
    rm_file(fname) if File.file?(fname)
  }
end

def rm_file(f)
  puts "Checking if #{f} exists" if $verbose
  return unless File.exists?(f)
  puts "Removing #{f}" if $verbose
  File.unlink(f)
end

def reset
  rm_file($domain_dat)
end

def reset_all
  reset
  rm_files($root_keydir)
  rm_files($user_keydir)
end

args = OptionParser.new { |opts|
  opts.banner = "Usage : sipxecs-setup [options]"

  opts.separator ""
  opts.separator "Options:"

  opts.on("--verbose", "Send extra details to console.") {
    $verbose = true
  }

  opts.on("--reset", "Force reset of normal settings.") {
    reset
  }

  opts.on("--reset-all", "Force reset of all possible settings including ssl keys.") {
    reset_all
  }

  opts.on_tail("--help", "Print options") {
    puts opts
    exit
  }

}
args.parse!

raise 'Must run as root' unless Process.uid == 0
rm_file($log)
set_root_keys()
set_nonroot_keys()
set_primary()
set_domain()

print "Configuring system, this may take a few minutes..."

run_command("@SIPX_BINDIR@/sipxagent" + ($verbose ? " -v" : ""))
puts "done."
