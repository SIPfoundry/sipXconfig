# Copyright (c) 2012 eZuce, Inc. All rights reserved.
# Contributed to SIPfoundry under a Contributor Agreement

# This software is free software; you can redistribute it and/or modify it under
# the terms of the Affero General Public License (AGPL) as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.

# This software is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.

#
# Initiate node backup  on this server or a full cluster backup from the primary
#
# NOTE:
# Required CF define is backup_id unique to each backup request. The reason it's 
# required and not generated here is that it is critical backups not be mixed 
# together.  If a backup from 2 days ago was grabbed instead of the current backup
# and a restore was done using this backup, results would be horribly incorrect.
# 
bundle agent backup {
  vars:
    any::
      "backup_dir" string => "@SIPX_TMPDIR@/backup";

    local_backup::
      "plan" string => "local";

    ftp_backup::
      "plan" string => "ftp";

    manual_backup::
      "plan" string => "manual";

  methods:
    any::
      "any" usebundle => "sipx_init";
      "any" usebundle => "sipx_module";
      "any" usebundle => "backup_node";

  files:
    any::
      "$(sipx.SIPX_CONFDIR)/backup-$(plan).yaml"
        comment => "Backup config $(this.promiser) from $(template)",
        create => "true",
        edit_defaults => empty,
        edit_line => expand_template("$(sipx.SIPX_CFDATA)/$(sipx.location_id)/backup-$(plan).yaml");

  commands:
    any::
      "$(sipx.SIPX_BINDIR)/sipx-archive"
        comment => "Backup config $(this.promiser)",
        args => "--backup backup-$(plan).yaml",
        classes => on_failed_command("1", "failed_backup");

  reports:
    failed_backup::
      "!!! Failed to complete $(plan) backup. See sipxagent.log for more details.";
}

# This does assume that backup ran successfully on *all* machines or at least cleared
# the old backups before failing. If that is not the case, we unknowingly collect old backups
# here.
bundle agent collect_backup {
  vars:
    any::
      "fqdn" slist => readstringlist("@SIPX_CFDATA@/servers", "=(.*?)end", "\n", 100, 4000);
      "dim_servers" int => readstringarray("server", "@SIPX_CFDATA@/servers", "#[^\n]*", "[\s=]", 100, 4000);
      "backup_id" string => execresult("/bin/date +%Y%m%d%k%M", "noshell");

  methods:
    any::
      "any" usebundle => "sipx_init";
      "any" usebundle => "sipx_module";
      "any" usebundle => backup_collect("$(backup_id)", "$(server[$(fqdn)][2])");
}

bundle agent collect_backup(backup_id, node_fqdn) {
  files:
    any::
      "@SIPX_VARDIR@/backup/$(backup_id)/."
        create => "true",
        perms => mog("644","@SIPXPBXUSER@","@SIPXPBXGROUP@");

      "@SIPX_VARDIR@/backup/$(backup_id)"
        perms => mog("644","@SIPXPBXUSER@","@SIPXPBXGROUP@"),
        copy_from => master_files("$(node_fqdn)", "@SIPX_TMPDIR@/backup"),
        depth_search => recurse("1");

  reports:
    linux::
      "Downloading backups from $(node_fqdn)";
}
