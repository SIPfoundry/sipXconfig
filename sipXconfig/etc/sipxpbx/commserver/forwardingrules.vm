<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- DO NOT EDIT THIS FILE. It is generated by sipXconfig web ui -->
<routes xmlns="http://www.sipfoundry.org/sipX/schema/xml/forwardingrules-00-00">
  <route mappingType="local">
    <description>
      Matches the SIPXCHANGE_DOMAIN_NAME (and all aliases for it).
      Routes SUBSCRIBE for message waiting indication to the status server.
      Routes SUBSCRIBE for "reg" events to the reg event server.
      All other requests go to the SIP registry/redirect service.
    </description>

    <routeFrom>${domainName}:${proxyAddress.port}</routeFrom>
    <routeFrom>${domainName}</routeFrom>
    <routeFrom>${location.address}:${proxyAddress.port}</routeFrom>
    <routeFrom>${location.address}</routeFrom>
    <routeFrom>${location.fqdn}:${proxyAddress.port}</routeFrom>
    <routeFrom>${location.fqdn}</routeFrom>
    <routeFrom>${location.hostname}:${proxyAddress.port}</routeFrom>
    <routeFrom>${location.hostname}</routeFrom>
#foreach ($route in ${routes})
    <routeFrom>$route:${proxyAddress.port}</routeFrom>
    <routeFrom>$route</routeFrom>
#end	    
    <methodMatch>
      <methodPattern>SUBSCRIBE</methodPattern>
#if( ${statusAddress} )

      <!-- Message waiting indication events -->
      <fieldMatch fieldName="Event">
        <fieldPattern>message-summary.*</fieldPattern>
        <!--this goes to the status server-->
        <routeTo ruriParams="sipx-noroute=Voicemail">&lt;${statusAddress.stripProtocol()};transport=tcp&gt;</routeTo>
      </fieldMatch>

#end
      <!-- "reg" event subscriptions. -->
      <fieldMatch fieldName="Event">
        <fieldPattern>reg</fieldPattern>
        <routeTo ruriParams="sipx-noroute=Voicemail">&lt;${regEventAddress.stripProtocol()};transport=tcp&gt;</routeTo>
      </fieldMatch>

      <!-- All other SUBSCRIBE requests go to the SIP registry service -->
      <routeTo ruriParams="sipx-noroute=Voicemail">&lt;${regAddress.stripProtocol()};transport=tcp;x-sipx-routetoreg&gt;</routeTo>

    </methodMatch>

    <!-- All other requests go to the SIP registry service -->
    <routeTo ruriParams="sipx-noroute=Voicemail">&lt;${regAddress.stripProtocol()};transport=tcp;x-sipx-routetoreg&gt;</routeTo>
  </route>

#if(${sbc.enabled})
#if(${exportLocalIpAddress})
    <route mappingType='local ip address'>
      <description>
        Any host address in the local subnets is routed to the auth proxy.
      </description>

    #foreach($subnet in ${sbc.routes.subnets})
      <routeIPv4subnet>$subnet</routeIPv4subnet>
    #end

    #foreach($domain in ${sbc.routes.domains})
      <routeDnsWildcard>$domain</routeDnsWildcard>
    #end

      <routeTo authRequired="true"/>
    </route>
#end
#foreach($auxSbc in $auxSbcs)
#if($auxSbc.enabled)
  <route mappingType='auxiliary SBC'>
    <description>
      Subnets and domains routed to ${auxSbc.address}
    </description>

#foreach($subnet in ${auxSbc.routes.subnets})
    <routeIPv4subnet>$subnet</routeIPv4subnet>
#end

#foreach($domain in ${auxSbc.routes.domains})
    <routeDnsWildcard>$domain</routeDnsWildcard>
#end

    <routeTo authRequired="true">${auxSbc.route}</routeTo>
  </route>
#end
#end

  <route mappingType="external destinations">
    <description>Any foreign domain - route via session border.</description>

    <routeDnsWildcard>*</routeDnsWildcard>
    <routeIPv4subnet>0/0</routeIPv4subnet>

    <routeTo authRequired="true">${sbc.route}</routeTo>
  </route>
#end

#foreach($bridgeSbc in $bridgeSbcs)
#foreach($sipTrunk in ${bridgeSbc.mySipTrunks})

  <route mappingType="itspname-callback">
    <description>
      Route url-dialed calls for itspname to the sipXbridge.
    </description>
    <routeFrom>${sipTrunk.address}</routeFrom>
    <routeTo authRequired='true'>${bridgeSbc.route}</routeTo>
  </route>
#end
#end
</routes>
